\chapter{SPARQL}
\label{chap:sparql}
TODO: ASK 

Bei SPARQL handelt es sich sich um eine Abfragesprache für RDF, welche es erlaubt datenquellenübergreifende Abfragen vorzunehmen. Dabei werden Anfragen in Graphen vollzogen, auch entlang derer Konjunktionen und Dijunktionen. SPARQL unterstützt zudem Aggregation, Unterabfragen, Negation sowie die Nutzung von Ausdrücken als Werte. Resultate sind entweder eine Menge von Ergebnissen oder RDF Graphen (vgl.~\cite[Abstract]{w3sparql_querylang}).

Eine Abfrage in SPARQL besteht aus den folgenden Komponenten:
\begin{itemize}
    \item Einem oder mehreren Namespaces
    \item Variablen
    \item Einem (Teil-) Graphen
    \item Einer Menge von Gruppierungen und Aggregationen
    \item Einer Menge von Modifikatoren
\end{itemize}
(vgl.~\cite[18.1.10 SPARQL Query]{w3sparql_querylang})

Informal kann gesagt werden, dass eine SPARQL-Abfrage aus \textit{Namespaces}, einer \textit{Select}-Klausel, einer \textit{Where}-Klausel sowie Modifikatoren besteht.

\section{Beispiel einer SPARQL Abfrage}
\label{sec:sparql_beispiel}

Gegeben sei die folgende Datenbasis:
\lstset{caption={Einfache Datenbasis direkt in SPARQL\protect\footnotemark},captionpos=b}
\lstset{language=XML}
\begin{lstlisting}
    <http://example.org/book/book1> <http://purl.org/dc/elements/1.1/title> "SPARQL Tutorial".
\end{lstlisting}
\footnotetext{\cite[2.1 Writing a Simple Query]{w3sparql_querylang}}

Die Datenbasis beinhaltet das Objekt \textit{book1} mit dem Attribut \textit{title}, welches den Wert \textit{``SPARQL Tutorial''} enthält.

Möchte man nun den Titel des Buches abfragen, so kann dies mit folgender Abfrage vorgenommen werden:
\lstset{caption={Beispiel einer einfachen SPARQL Abfrage\protect\footnotemark},captionpos=b}
\begin{lstlisting}
    SELECT ?title
    WHERE
    {
      <http://example.org/book/book1> <http://purl.org/dc/elements/1.1/title> ?title .
    }
\end{lstlisting}
\footnotetext{\cite[2.1 Writing a Simple Query]{w3sparql_querylang}}

Die obige Abfrage ergibt folgendes Resultat:
\noindent\hspace*{15mm}
\begin{table}[h]
    \centering
    \begin{tabular}{|l|}
        \hline
        \multicolumn{1}{|c|}{\textbf{title}} \\ \hline
        ``SPARQL Tutorial''                    \\ \hline
    \end{tabular}
    \caption{Resultat einer einfachen SPARQL Abfrage\protect\footnotemark}
\end{table}
\footnotetext{\cite[2.1 Writing a Simple Query]{w3sparql_querylang}}

\section{Namespaces}
\label{sec:sparql_namespaces}

Da es sich bei SPARQL um eine Abfragesprache für RDF handelt und dieses auf XML basiert, sind XML Namespaces auch in SPARQL verfügbar. Bei Namespaces handelt es sich im Prinzip um Module, in Form anderer XML basierter Dokumente, welche referenziert und genutzt werden können. Ein (XML-) Namespace besteht aus einem Kürzel (welches auch leer sein kann), sowie der kompletten Adresse der Ressource (vgl.~\cite[2.1 Introduction]{w3rdf_syntax}).

\lstset{language=XML,
  caption={Beispiel von Namespaces in RDF\protect\footnotemark},
  frame=L,
  basicstyle=\small\normalfont\sffamily,  % the size of the fonts that are used for the code
  stepnumber=1,                           % the step between two line-numbers.
                                          % If it is 1 each line will be numbered
  numbersep=10pt,                         % how far the line-numbers are from the code
  tabsize=2,                              % tab size in blank spaces
  extendedchars=true,                     %
  breaklines=true,                        % sets automatic line breaking
  captionpos=b,                           % sets the caption-position to bottom
  mathescape=true,
  showspaces=false,                       % Leerzeichen anzeigen ?
  showtabs=false,                         % Tabs anzeigen ?
  xleftmargin=17pt,
  framexleftmargin=17pt,
  framexrightmargin=17pt,
  framexbottommargin=5pt,
  framextopmargin=5pt,
  showstringspaces=false                  % Leerzeichen in Strings anzeigen ?
  belowcaptionskip=5em,
  belowskip=3em,
  aboveskip=3em
 }
\begin{lstlisting}
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  % chktex 1
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:ex="http://example.org/stuff/1.0/">
\end{lstlisting}
\footnotetext{\cite[2.6 Completing the Document: Document Element and XML Declaration]{w3rdf_syntax}}

\section{Variablen}
\label{sec:sparql_variablen}

SPARQL unterstützt die Verwendung von Variablen bei Abfragen, diese können dabei an einer beliebigen Stelle --- also bei (Teil-) Graphen, Gruppierungen, Aggregationen und Modifikatoren --- eingesetzt werden.
Sie dienen als Plathalter für abzufragende Objekte, Subjekte oder Prädikate. Variablen beginnen entweder mit einem Dollarzeichen \textit{\$} oder einem Fragezeichen \textit{?}, welche aber nicht Teil der Variable sind.

\lstset{caption={Beispiel einer SPARQL Abfrage mit den Variablen \textit{?object}, \textit{?predicate} und \textit{?subject}.},captionpos=b}
\begin{lstlisting}
    SELECT DISTINCT
        *
    WHERE {
      ?object ?predicate ?subject
    }
    LIMIT
        10
\end{lstlisting}

Wird obige Anfrage auf einen SPARQL-Endpunkt, wie z.B. \textit{http://dbpedia.org/}, angewendet, so ergibt dies das folgende Resultat:
\noindent\hspace*{15mm}
\begin{table}[h]
    \centering
    \begin{tabular}{l|l|l|}
        \hline
        \multicolumn{1}{c|}{\textbf{object}}                                & \textbf{predicate}                               & \textbf{subject}                                  \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/acceleration}      & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/torqueOutput}      & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/birthDate}         & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/birthYear}         & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/deathDate}         & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/deathYear}         & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/diameter}          & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/displacement}      & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/height}            & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/latestReleaseDate} & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
    \end{tabular}
    \caption{Resultat einer Abfrage des DBPedia-Endpunktes limitiert auf 10 Ergebnisse.}
\end{table}



\section{(Teil-) Graphen}
\label{sec:sparql_graph}

SPARQL basiert auf dem Matching eines (Teil-) Graphen in einem gegebenen Graphen. Dabei ist ein (Teil-) Graph eine Menge von Trippeln.

Es wird zwischen den folgenden Arten von Teilgraphen unterschieden:
\begin{itemize}
\item \textit{Grundlegende Teilgraphen}

Hier muss eine Menge von Trippeln denen in dem gegebenen Graphen entsprechen

\item \textit{Gruppierende Teilgraphen}

Hier müssen alle Elemente einer Menge von grundlegenden Teilgraphen denen in dem gegebenen Graphen entsprechen

\item \textit{Optionale Teilgraphen}

Zusätzliche Teilgraphen können die Lösungsmenge erweitern

\item \textit{Alternative Teilgraphen}

Es wird versucht, dass zwei oder mehrere mögliche Teilgraphen denen in dem gegebenen Graphen entsprechen

\item \textit{Teilgraphen in namensbasierten Graphen}

Es wird versucht Teilgraphen denen in dem gegebenen, namensbasierten Graphen zu entsprechen
\end{itemize}

Ein grundlegender Teilgraph ist also eine Menge von Trippeln, wobei ein Trippel gemäss RDF-Spezifikation immer aus Subjekt, Prädikat und Objekt besteht.~\cite[3.1 Triples]{w3rdf}

\lstset{caption={Beispiel eines grundlegen Teilgraphen in SPARQL}}
\lstset{language=XML}
\begin{lstlisting}
    ?subject ?predicate ?object.
\end{lstlisting}

Informal kann gesagt werden, dass ein Teilgraph in SPARQL immer zur Gruppierung einer Abfrage verwendet wird, was in der SQL-Sprache der \textit{Where}-Klausel entspricht. Ein Teilgraph wird immer mit dem Punkt-Operator beendet.

In einem SPARQL-Abfragestring wird ein gruppierender Teilgraph immer mit geschweiften Klammern \textit{\{\}} umschlossen. Es ist möglich die Resultate einer Gruppe zu Filtern, dazu wird das \textit{FILTER} Schlüsselwort eingesetzt. Dieses bezieht sich immer auf die Gruppe, in welcher es angwendet wird.

\lstset{caption={Beispiel eines gruppierenden Teilgraphen mit \textit{FILTER} Schlüsselwort\protect\footnotemark}}
\lstset{language=XML}
\begin{lstlisting}
    {
        ?x foaf:name ?name.
        ?x foaf:mbox ?mbox.
        FILTER regex(?name, "Smith")
    }
\end{lstlisting}
\footnotetext{\cite[5.2.2 Scope of Filters]{w3sparql_querylang}}

In obigem Beispiel werden alle Objekte sowie die Werte derer Attribute \textit{name} und \textit{mbox} des Namespaces \textit{foaf} abgefragt. Dabei kann eine komplette leere Menge --- wenn keine Objekte vorhanden sind --- oder aber eine leere Teilmenge --- wenn ein Objekt z.B. nicht über beide Attribute verfügt --- zurückgegeben werden. Die resultierende Menge wird anschliessend gefiltert, so dass nur Objekte zurückbleiben, welche über ein Attribut \textit{foaf:name} verfügen und dessen Inhalt \textit{``Smith''} ist.

\section{Gruppierungen und Aggregationen}
\label{sec:sparql_gruppierungenaggregationen}

Aggregationen wenden Ausdrücke auf eine Lösungsmenge an, wobei eine Lösung normalerweise eine einzelne Gruppe mit allen Lösungen darin enthält. Gruppierungen werden mittels \textit{GROUP BY} angegeben.
SPARQL unterstützt aktuell die Aggregationen \textit{COUNT}, \textit{SUM}, \textit{MIN}, \textit{MAX}, \textit{AVG}, \textit{GROUP\_CONCAT} und \textit{SAMPLE}. Eine Aggregation kommt dann zum Einsatz, wenn ein Resultat über eine Gruppe von Lösungen berechnet werden soll, wie zum Beispiel den maximalen Wert einer bestimmten Variable (vgl.~\cite[11 Aggregates]{w3sparql_querylang}).

\lstset{caption={Beispiel einer Abfrage mit Gruppierung und Aggregation\protect\footnotemark}}
\lstset{language=SQL}
\begin{lstlisting}
    PREFIX books: <http://books.example/>
    SELECT (
        SUM(?lprice) AS ?totalPrice
    )
    WHERE {
      ?org books:affiliates ?auth .
      ?auth books:writesBook ?book .
      ?book books:price ?lprice .
    }
    GROUP BY ?org
    HAVING (SUM(?lprice) > 10)
\end{lstlisting}
\footnotetext{\cite[11.1 Aggregate Example]{w3sparql_querylang}}

\section{Modifikatoren}
\label{sec:sparql_modifikatoren}

Abfragen mittels SPARQL generieren eine ungeordnete Menge von Lösungen, wobei jede dieser Lösungen eine Funktion von Variablen zu RDF-Termen darstellt. Solche Lösungen werden als Sequenz von Lösungen behandelt, initial allerdings ohne spezifische Ordnung.~\cite[15 Solution Sequences and Modifiers]{w3sparql_querylang}

Um eine Sequenz von Lösungen zu ordnen, können Modifikatoren verwendet werden. Man unterscheidet dabei zwischen folgenden Modifikatoren:

\begin{itemize}
\item \textit{Order}

Sortiert die Lösungen nach einer gewissen Variable, entweder ab- oder aufsteigend

\item \textit{Projection}

Erlaubt die Auswahl von spezifischen Variablen mittels der \textit{Select}-Klausel

\item \textit{Distinct}

Stellt sicher, dass die Lösungen in der Lösungsmenge einmalig sind

\item \textit{Reduced}

Verhindert die Elimination von Duplikaten in der Lösungsmenge

\item \textit{Offset}

Definiert ab welcher Lösung die gefundenen Lösungen ausgegeben werden sollen

\item \textit{Limit}

Definiert die maximale Anzahl der gefunden Lösungen, welche ausgegeben werden sollen

\end{itemize}

Die Modifikatoren werden in der Reihenfolge der obigen Liste angewendet.~\cite[vgl. 15 Solution Sequences and Modifiers]{w3sparql_querylang}


% Einträge im Verzeichnis erscheinen lassen ohne hier eine Referenz einzufügen
%\nocite{kopka:band1}
