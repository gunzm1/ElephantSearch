\chapter{SPARQL}
\label{chap:sparql}
Das folgende Kapitel basiert, sofern nicht anders vermerkt, auf~\cite{w3sparql_querylang}.

Bei SPARQL handelt es sich sich um eine Abfragesprache für RDF, welche es erlaubt datenquellenübergreifende Abfragen vorzunehmen. Dabei werden Anfragen in Graphen vollzogen, auch entlang derer Konjunktionen und Dijunktionen. SPARQL unterstützt zudem Aggregation, Unterabfragen, Negation sowie die Nutzung von Ausdrücken als Werte. Resultate sind entweder eine Menge von Ergebnissen oder RDF Graphen (vgl.~\cite[Abstract]{w3sparql_querylang}).

Eine Abfrage in SPARQL besteht aus den folgenden Komponenten:
\begin{itemize}
    \item Einem oder mehreren Namespaces
    \item Variablen
    \item Einem (Teil-) Graphen
    \item Einer Menge von Gruppierungen und Aggregationen
    \item Einer Menge von Modifikatoren
    \item Abfragearten
    \item Ausdrücken und Wertevergleichen
\end{itemize}
(vgl.~\cite[18.1.10 SPARQL Query]{w3sparql_querylang})

Informal kann gesagt werden, dass eine SPARQL-Abfrage aus \textit{Namespaces}, einer \textit{Select}-Klausel, einer \textit{Where}-Klausel sowie Modifikatoren besteht.

\section{Beispiel einer SPARQL Abfrage}
\label{sec:sparql_beispiel}

Gegeben sei die folgende Datenbasis:
\lstset{caption={Einfache Datenbasis direkt in SPARQL\protect\footnotemark},captionpos=b}
\lstset{language=XML}
\begin{lstlisting}
    <http://example.org/book/book1> <http://purl.org/dc/elements/1.1/title> "SPARQL Tutorial".
\end{lstlisting}
\footnotetext{\cite[2.1 Writing a Simple Query]{w3sparql_querylang}}

Die Datenbasis beinhaltet das Objekt \textit{book1} mit dem Attribut \textit{title}, welches den Wert \textit{``SPARQL Tutorial''} enthält.

Möchte man nun den Titel des Buches abfragen, so kann dies mit folgender Abfrage vorgenommen werden:
\lstset{caption={Beispiel einer einfachen SPARQL Abfrage\protect\footnotemark},captionpos=b}
\begin{lstlisting}
    SELECT ?title
    WHERE
    {
      <http://example.org/book/book1> <http://purl.org/dc/elements/1.1/title> ?title .
    }
\end{lstlisting}
\footnotetext{\cite[2.1 Writing a Simple Query]{w3sparql_querylang}}

Die obige Abfrage ergibt folgendes Resultat:
\noindent\hspace*{15mm}
\begin{table}[h]
    \centering
    \begin{tabular}{|l|}
        \hline
        \multicolumn{1}{|c|}{\textbf{title}} \\ \hline
        ``SPARQL Tutorial''                    \\ \hline
    \end{tabular}
    \caption{Resultat einer einfachen SPARQL Abfrage\protect\footnotemark}
\end{table}
\footnotetext{\cite[2.1 Writing a Simple Query]{w3sparql_querylang}}

\section{Namespaces}
\label{sec:sparql_namespaces}

Da es sich bei SPARQL um eine Abfragesprache für RDF handelt und dieses auf XML basiert, sind XML Namespaces auch in SPARQL verfügbar. Bei Namespaces handelt es sich im Prinzip um Module, in Form anderer XML basierter Dokumente, welche referenziert und genutzt werden können. Ein (XML-) Namespace besteht aus einem Kürzel (welches auch leer sein kann), sowie der kompletten Adresse der Ressource (vgl.~\cite[2.1 Introduction]{w3rdf_syntax}).

\lstset{language=XML,
  caption={Beispiel von Namespaces in RDF\protect\footnotemark},
  frame=L,
  basicstyle=\small\normalfont\sffamily,  % the size of the fonts that are used for the code
  stepnumber=1,                           % the step between two line-numbers.
                                          % If it is 1 each line will be numbered
  numbersep=10pt,                         % how far the line-numbers are from the code
  tabsize=2,                              % tab size in blank spaces
  extendedchars=true,                     %
  breaklines=true,                        % sets automatic line breaking
  captionpos=b,                           % sets the caption-position to bottom
  mathescape=true,
  showspaces=false,                       % Leerzeichen anzeigen ?
  showtabs=false,                         % Tabs anzeigen ?
  xleftmargin=17pt,
  framexleftmargin=17pt,
  framexrightmargin=17pt,
  framexbottommargin=5pt,
  framextopmargin=5pt,
  showstringspaces=false                  % Leerzeichen in Strings anzeigen ?
  belowcaptionskip=5em,
  belowskip=3em,
  aboveskip=3em
 }
\begin{lstlisting}
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  % chktex 1
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xmlns:ex="http://example.org/stuff/1.0/">
\end{lstlisting}
\footnotetext{\cite[2.6 Completing the Document: Document Element and XML Declaration]{w3rdf_syntax}}

\section{Variablen}
\label{sec:sparql_variablen}

SPARQL unterstützt die Verwendung von Variablen bei Abfragen, diese können dabei an einer beliebigen Stelle --- also bei (Teil-) Graphen, Gruppierungen, Aggregationen und Modifikatoren --- eingesetzt werden.
Sie dienen als Plathalter für abzufragende Objekte, Subjekte oder Prädikate. Variablen beginnen entweder mit einem Dollarzeichen \textit{\$} oder einem Fragezeichen \textit{?}, welche aber nicht Teil der Variable sind.

\lstset{caption={Beispiel einer SPARQL Abfrage mit den Variablen \textit{?object}, \textit{?predicate} und \textit{?subject}.},captionpos=b}
\begin{lstlisting}
    SELECT DISTINCT
        *
    WHERE {
      ?object ?predicate ?subject
    }
    LIMIT
        10
\end{lstlisting}

Wird obige Anfrage auf einen SPARQL-Endpunkt, wie z.B. \textit{http://dbpedia.org/}, angewendet, so ergibt dies das folgende Resultat:
\noindent\hspace*{15mm}
\begin{table}[h]
    \centering
    \begin{tabular}{l|l|l|}
        \hline
        \multicolumn{1}{c|}{\textbf{object}}                                & \textbf{predicate}                               & \textbf{subject}                                  \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/acceleration}      & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/torqueOutput}      & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/birthDate}         & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/birthYear}         & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/deathDate}         & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/deathYear}         & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/diameter}          & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/displacement}      & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/height}            & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
        \multicolumn{1}{|l|}{http://dbpedia.org/ontology/latestReleaseDate} & ... rdf-syntax-ns\#type & ... owl\#FunctionalProperty \\ \hline
    \end{tabular}
    \caption{Resultat einer Abfrage des DBPedia-Endpunktes limitiert auf 10 Ergebnisse.}
\end{table}



\section{(Teil-) Graphen}
\label{sec:sparql_graph}

SPARQL basiert auf dem Matching eines (Teil-) Graphen in einem gegebenen Graphen. Dabei ist ein (Teil-) Graph eine Menge von Tripeln.

Es wird zwischen den folgenden Arten von Teilgraphen unterschieden:
\begin{itemize}
\item \textit{Grundlegende Teilgraphen}

Hier muss eine Menge von Tripeln denen in dem gegebenen Graphen entsprechen

\item \textit{Gruppierende Teilgraphen}

Hier müssen alle Elemente einer Menge von grundlegenden Teilgraphen denen in dem gegebenen Graphen entsprechen

\item \textit{Optionale Teilgraphen}

Zusätzliche Teilgraphen können die Lösungsmenge erweitern

\item \textit{Alternative Teilgraphen}

Es wird versucht, dass zwei oder mehrere mögliche Teilgraphen denen in dem gegebenen Graphen entsprechen

\item \textit{Teilgraphen in namensbasierten Graphen}

Es wird versucht Teilgraphen denen in dem gegebenen, namensbasierten Graphen zu entsprechen
\end{itemize}

Ein grundlegender Teilgraph ist also eine Menge von Tripeln, wobei ein Tripel gemäss RDF-Spezifikation immer aus Subjekt, Prädikat und Objekt besteht.~\cite[3.1 Triples]{w3rdf}

\lstset{caption={Beispiel eines grundlegen Teilgraphen in SPARQL}}
\lstset{language=XML}
\begin{lstlisting}
    ?subject ?predicate ?object.
\end{lstlisting}

Informal kann gesagt werden, dass ein Teilgraph in SPARQL immer zur Gruppierung einer Abfrage verwendet wird, was in der SQL-Sprache der \textit{Where}-Klausel entspricht. Ein Teilgraph wird immer mit dem Punkt-Operator beendet.

In einem SPARQL-Abfragestring wird ein gruppierender Teilgraph immer mit geschweiften Klammern \textit{\{\}} umschlossen. Es ist möglich die Resultate einer Gruppe zu Filtern, dazu wird das \textit{FILTER} Schlüsselwort eingesetzt. Dieses bezieht sich immer auf die Gruppe, in welcher es angwendet wird.

\lstset{caption={Beispiel eines gruppierenden Teilgraphen mit \textit{FILTER} Schlüsselwort\protect\footnotemark}}
\lstset{language=XML}
\begin{lstlisting}
    {
        ?x foaf:name ?name.
        ?x foaf:mbox ?mbox.
        FILTER regex(?name, "Smith")
    }
\end{lstlisting}
\footnotetext{\cite[5.2.2 Scope of Filters]{w3sparql_querylang}}

In obigem Beispiel werden alle Objekte sowie die Werte derer Attribute \textit{name} und \textit{mbox} des Namespaces \textit{foaf} abgefragt. Dabei kann eine komplette leere Menge --- wenn keine Objekte vorhanden sind --- oder aber eine leere Teilmenge --- wenn ein Objekt z.B. nicht über beide Attribute verfügt --- zurückgegeben werden. Die resultierende Menge wird anschliessend gefiltert, so dass nur Objekte zurückbleiben, welche über ein Attribut \textit{foaf:name} verfügen und dessen Inhalt \textit{``Smith''} ist.

\section{Gruppierungen und Aggregationen}
\label{sec:sparql_gruppierungenaggregationen}

Aggregationen wenden Ausdrücke auf eine Lösungsmenge an, wobei eine Lösung normalerweise eine einzelne Gruppe mit allen Lösungen darin enthält. Gruppierungen werden mittels \textit{GROUP BY} angegeben.
SPARQL unterstützt aktuell die Aggregationen \textit{COUNT}, \textit{SUM}, \textit{MIN}, \textit{MAX}, \textit{AVG}, \textit{GROUP\_CONCAT} und \textit{SAMPLE}. Eine Aggregation kommt dann zum Einsatz, wenn ein Resultat über eine Gruppe von Lösungen berechnet werden soll, wie zum Beispiel den maximalen Wert einer bestimmten Variable (vgl.~\cite[11 Aggregates]{w3sparql_querylang}).

\lstset{caption={Beispiel einer Abfrage mit Gruppierung und Aggregation\protect\footnotemark}}
\lstset{language=SQL}
\begin{lstlisting}
    PREFIX books: <http://books.example/>
    SELECT (
        SUM(?lprice) AS ?totalPrice
    )
    WHERE {
      ?org books:affiliates ?auth .
      ?auth books:writesBook ?book .
      ?book books:price ?lprice .
    }
    GROUP BY ?org
    HAVING (SUM(?lprice) > 10)
\end{lstlisting}
\footnotetext{\cite[11.1 Aggregate Example]{w3sparql_querylang}}

\section{Modifikatoren}
\label{sec:sparql_modifikatoren}

Abfragen mittels SPARQL generieren eine ungeordnete Menge von Lösungen, wobei jede dieser Lösungen eine Funktion von Variablen zu RDF-Termen darstellt. Solche Lösungen werden als Sequenz von Lösungen behandelt, initial allerdings ohne spezifische Ordnung.~\cite[15 Solution Sequences and Modifiers]{w3sparql_querylang}

Um eine Sequenz von Lösungen zu ordnen, können Modifikatoren verwendet werden. Man unterscheidet dabei zwischen folgenden Modifikatoren:

\begin{itemize}
\item \textit{Order}

Sortiert die Lösungen nach einer gewissen Variable, entweder ab- oder aufsteigend

\item \textit{Projection}

Erlaubt die Auswahl von spezifischen Variablen mittels der \textit{Select}-Klausel

\item \textit{Distinct}

Stellt sicher, dass die Lösungen in der Lösungsmenge einmalig sind

\item \textit{Reduced}

Verhindert die Elimination von Duplikaten in der Lösungsmenge

\item \textit{Offset}

Definiert ab welcher Lösung die gefundenen Lösungen ausgegeben werden sollen

\item \textit{Limit}

Definiert die maximale Anzahl der gefunden Lösungen, welche ausgegeben werden sollen

\end{itemize}

Die Modifikatoren werden in der Reihenfolge der obigen Liste angewendet.~\cite[vgl. 15 Solution Sequences and Modifiers]{w3sparql_querylang}


\section{Abfragearten}
\label{sec:sparql_abfragearten}

SPARQL unterscheidet zwischen vier Abfragearten:
\begin{itemize}
    \item \textit{SELECT}

        Gibt alle bzw.\ eine Teilmenge der Variablen eines (Teil-) Graphen zurück
    \item \textit{CONSTRUCT}

        Gibt einen RDF Graphen durch Substitution der Variablen in einer Menge von gegebenen Tripeln zurück
    \item \textit{ASK}

        Gibt einen Wahrheitswert (Boolean) zurück, welcher angibt, ob die Menge von angefragten Tripeln denen in dem gegebenen Graphen entsprechen oder nicht
    \item \textit{DESCRIBE}

        Gibt einen RDF Graphen zurück, welcher die gefundenen Ressourcen beschreibt
\end{itemize}

\subsection{SELECT}
\label{subsec:sparql_abfragearten_select}
Die \textit{SELECT}-Abfrageart gibt Variablen und deren Belegung direkt, in Form von Projektionen, zurück. Dabei werden neue Variablen-Belegungen generiert. Die spezifischen, gewünschten Variablen werden in Form einer Liste, per Leerschlag getrennt, angegeben.

\lstset{caption={Beispiel der \textit{SELECT}-Abfrageart in SPARQL},captionpos=b,language=SQL}
\begin{lstlisting}
SELECT ?a ?b ?c
WHERE {
...
\end{lstlisting}

Die $ SELECT * $ Syntax ist dabei eine Kurzschreibweise und beduetet eigentlich die Verwendung bzw. Auflistung aller in der Abfrage verwendeten Variablen. Ausgenommen sind Variablen innerhalb von \textit{FILTER}-Anweisungen sowie Variablen, welche rechts des Minus-Operators stehen. Die Syntax darf nur verwendet werden, wenn die Abfrage keine \textit{GROUP BY} Aggregation verwendet.
\lstset{caption={Beispiel der \textit{SELECT *} Kurzschreibweise in SPARQL},captionpos=b,language=SQL}
\begin{lstlisting}
SELECT *
WHERE {
...
\end{lstlisting}

Die \textit{SELECT}-Abfrageart bietet die Möglichkeit neue Variable durch Ausdrücke einzuführen. Diese werden mittels $(expr AS V)$ eingeführt.

\lstset{caption={Beispiel eines Ausdrucks der \textit{SELECT}-Abfrageart},captionpos=b,language=SQL}
\begin{lstlisting}
SELECT ?title (?p * (1 - ?discount) AS ?price)
WHERE {
...
\end{lstlisting}


\subsection{CONSTRUCT}
\label{subsec:sparql_abfragearten_construct}
Die \textit{CONSTRUCT}-Abfrageart gibt einen RDF Graphen durch Substitution der Variablen in einer Menge von gegebenen Tripeln zurück. Dabei wird jede Lösung der Abfrage in die Lösungssequenz, unter Substitution der Variablen in der gegebenen Vorlage des Graphen, überführt. Die Lösungsmenge wird schliesslich per Vereinigung auf einen einzigen RDF Graphen reduziert.

\lstset{caption={Beispiel einer SPARQL Abfrage mit Nutzung der \textit{CONSTRUCT}-Abfrageart\protect\footnotemark},captionpos=b}
\begin{lstlisting}
PREFIX foaf:    <http://xmlns.com/foaf/0.1/>
PREFIX vcard:   <http://www.w3.org/2001/vcard-rdf/3.0#>
CONSTRUCT   { <http://example.org/person#Alice> vcard:FN ?name }
WHERE       { ?x foaf:name ?name }
\end{lstlisting}
\footnotetext{\cite[16.2 CONSTRUCT]{w3sparql_querylang}}

Die obige Abfrage erzeugt folgende Ausgabe:
\lstset{caption={Beispiel der Ausgabe einer SPARQL Abfrage mit Nutzung der \textit{CONSTRUCT}-Abfrageart\protect\footnotemark},captionpos=b}
\begin{lstlisting}
@prefix vcard: <http://www.w3.org/2001/vcard-rdf/3.0#> .

<http://example.org/person#Alice> vcard:FN "Alice" .
\end{lstlisting}
\footnotetext{\cite[16.2 CONSTRUCT]{w3sparql_querylang}}

Wird bei diesem Vorgang ein ungültiges Tripel erzeugt, so wird dieses Tripel im Ausgabegraphen nicht angezeigt. Enthält die Vorlage eine Graphen Tripel ohne Variablen, erscheinen diese dennoch im Ausgabegraphen.

\lstset{caption={Beispiel einer SPARQL Abfrage mit Nutzung der \textit{CONSTRUCT}-Abfrageart unter Verwendung leerer Knoten\protect\footnotemark},captionpos=b}
\begin{lstlisting}
PREFIX foaf:    <http://xmlns.com/foaf/0.1/>
PREFIX vcard:   <http://www.w3.org/2001/vcard-rdf/3.0#>

CONSTRUCT { ?x  vcard:N _:v .
            _:v vcard:givenName ?gname .
            _:v vcard:familyName ?fname }
WHERE
 {
    { ?x foaf:firstname ?gname } UNION  { ?x foaf:givenname   ?gname } .
    { ?x foaf:surname   ?fname } UNION  { ?x foaf:family_name ?fname } .
 }
\end{lstlisting}
\footnotetext{\cite[16.2.1 Templates with Blank Nodes]{w3sparql_querylang}}

Die obige Abfrage erzeugt folgende Ausgabe:
\lstset{caption={Beispiel der Ausgabe einer SPARQL Abfrage mit Nutzung der \textit{CONSTRUCT}-Abfrageart unter Verwendung leerer Knoten\protect\footnotemark},captionpos=b}
\begin{lstlisting}
@prefix vcard: <http://www.w3.org/2001/vcard-rdf/3.0#> .

_:v1 vcard:N         _:x .
_:x vcard:givenName  "Alice" .
_:x vcard:familyName "Hacker" .

_:v2 vcard:N         _:z .
_:z vcard:givenName  "Bob" .
_:z vcard:familyName "Hacker" .
\end{lstlisting}
\footnotetext{\cite[16.2.1 Templates with Blank Nodes]{w3sparql_querylang}}

\subsection{ASK}
\label{subsec:sparql_abfragearten_ask}
Die \textit{ASK}-Abfrageart ermöglicht die Ausgabe, ob eine Lösung für die gegebene Abfrage existiert oder nicht.

Gegeben sei die folgende Datenbasis:
\lstset{caption={Einfache Datenbasis direkt in SPARQL\protect\footnotemark},captionpos=b}
\lstset{language=XML}
\begin{lstlisting}
@prefix foaf:       <http://xmlns.com/foaf/0.1/> .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   <http://work.example.org/alice/> .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       <mailto:bob@work.example> .
\end{lstlisting}
\footnotetext{\cite[16.3 ASK]{w3sparql_querylang}}

Wird nun folgende Abfrage getätigt:
\lstset{caption={Beispiel einer SPARQL-Abfrage mit Nutzung der \textit{ASK}-Abfrageart\protect\footnotemark},captionpos=b}
\lstset{language=XML}
\begin{lstlisting}
PREFIX foaf:    <http://xmlns.com/foaf/0.1/>
ASK  { ?x foaf:name  "Alice" }
\end{lstlisting}
\footnotetext{\cite[16.3 ASK]{w3sparql_querylang}}
So gibt das System $true.$ zurück, da die Datenbasis ein Individuum mit dem Attribut $foaf:name$ dessen Wert $'Alice'$ ist.

\subsection{DESCRIBE}
\label{subsec:sparql_abfragearten_describe}
Die \textit{DESCRIBE}-Abfrageart gibt einen RDF Graphen mit Informationen in Form von RDF-Daten über Ressourcen zurück. Ressourcen können dabei \textit{IRI}s oder Variablen sein.

\lstset{caption={Beispiel der \textit{DESCRIBE}-Abfrageart in SPARQL},captionpos=b,language=SQL}
\begin{lstlisting}
DESCRIBE ?a ?b ?c
WHERE {
...
\end{lstlisting}

Die $ DESCRIBE * $ Syntax ist dabei eine Kurzschreibweise und beduetet eigentlich die Verwendung bzw. Auflistung aller in der Abfrage verwendeten Variablen. 
\lstset{caption={Beispiel der \textit{DESCRIBE *} Kurzschreibweise in SPARQL},captionpos=b,language=SQL}
\begin{lstlisting}
DESCRIBE *
WHERE {
...
\end{lstlisting}

\section{Ausdrücke und Wertevergleiche}
\label{sec:sparql_ausdruecke}

Jede Abfrage in SPARQL kann mit einem so genannten Filter versehen werden. Dabei wird versucht ein gewisses Muster, gegeben durch Beschränkungen, auf (Teil-) Graphen anzuwenden um so die (Teil-) Graphen einzuschränken oder eben zu filtern.

Jedes RDF-Literal kann durch einen bestimmten Datentyp definiert sein, so z.B. Wahrheitswerte (Boolean) oder Datum und Uhrzeit (DateTime). Der Filter in SPARQL erlaubt dabei den Wertevergleich auf typisierte RDF-Literale. Die dabei verwendeten Operanden und Datentypen finden sich unter~\footnote{http://www.w3.org/TR/xpath-functions/} und~\footnote{http://www.w3.org/TR/sparql11-query/\#operandDataTypes}.

Eine SPARQL-Abfrage unter Verwendung eines Filters kann zum Beispiel wie folgt aussehen:
\lstset{caption={Beispiel einer einfachen SPARQL Abfrage unter Verwendung eines Filters},captionpos=b}
\begin{lstlisting}
    ...
    SELECT ?book
    WHERE
    {
      ?book :isInLibrary :BerneUniversityLibrary
      ?book :hasAmount ?amount
      FILTER (?amount > xsd:integer(10))
    }
\end{lstlisting}
Hier werden alle Bücher abgefragt, welche sich in der Bibliothek der Universität von Bern befinden und deren (allgemeines) Vorkommen grösser als 10 ist.

Ist man in obigem Beispiel nicht sicher, welcher Datentyp die Variable $?amount$ entspricht, so kann man die Funktionalität zur Umwandlung (Casting) durch SPARQL nutzen:
\lstset{caption={Beispiel einer einfachen SPARQL Abfrage unter Verwendung eines Filters mit Typumwandlung},captionpos=b}
\begin{lstlisting}
    ...
    SELECT ?book
    WHERE
    {
      ?book :isInLibrary :BerneUniversityLibrary
      ?book :hasAmount ?amount
      FILTER (xsd:integer(?amount) > xsd:integer(10))
    }
\end{lstlisting}

Die genaue Auswertung eines Filters lässt sich unter~\footnote{http://www.w3.org/TR/sparql11-query/\#evaluation} nachlesen. Die interne Verwendung und Auswertung von Operatoren lässt sich unter~\footnote{http://www.w3.org/TR/sparql11-query/\#OperatorMapping} nachlesen.

\subsection{Funktionen}
\label{subsec:sparql_ausdruecke_funktionen}

SPARQL bietet eine Vielzahl an Operatoren und Funktionen. Diese alle einzeln aufzuführen und zu beschreiben würde den Rahmen dieses Dokumentes sprengen, daher werden nur die von den Autoren als am häufigsten genutzten Operatoren und Funktionen aufgeführt. Eine genauere Beschreibung findet sich unter~\footnote{http://www.w3.org/TR/sparql11-query/\#SparqlOps}.

\subsubsection{BOUND}
\label{subsec:sparql_ausdruecke_funktionen_bound}
Mittels \textit{BOUND} lässt sich prüfen, ob ein Objekt an einen Wert gebunden ist oder nicht. Man kann dies als eine Art Überprüfung auf gewisse Eigenschaften verstehen.

Möchte man zum Beispiel wissen, welche Personen alle über eine Relation zu einem Datum (z.B. Erfassungsdatum) verfügen, so geschieht dies mittels:

\lstset{caption={Beispiel einer simplen Ontologie zur Nutzung der \textit{BOUND}-Funktion in einer Abfrage\protect\footnotemark},captionpos=b}
\begin{lstlisting}
@prefix foaf:        <http://xmlns.com/foaf/0.1/> .
@prefix dc:          <http://purl.org/dc/elements/1.1/> .
@prefix xsd:          <http://www.w3.org/2001/XMLSchema#> .

_:a  foaf:givenName  "Alice".

_:b  foaf:givenName  "Bob" .
_:b  dc:date         "2005-04-04T04:04:04Z"^^xsd:dateTime .
\end{lstlisting}
\footnotetext{\cite[17.4.1.1 BOUND]{w3sparql_querylang}}

\lstset{caption={Beispiel einer einfachen SPARQL Abfrage zur Nutzung der \textit{BOUND}-Funktion\protect\footnotemark},captionpos=b}
\begin{lstlisting}
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX dc:   <http://purl.org/dc/elements/1.1/>
PREFIX xsd:   <http://www.w3.org/2001/XMLSchema#>
SELECT ?givenName
 WHERE { ?x foaf:givenName  ?givenName .
         OPTIONAL { ?x dc:date ?date } .
         FILTER ( bound(?date) ) }
\end{lstlisting}
\footnotetext{\cite[17.4.1.1 BOUND]{w3sparql_querylang}}

Die obige Abfrage ergibt folgendes Resultat:
\noindent\hspace*{15mm}
\begin{table}[h]
    \centering
    \begin{tabular}{|l|}
        \hline
        \multicolumn{1}{|c|}{\textbf{givenName}} \\ \hline
        ``Bob''                    \\ \hline
    \end{tabular}
    \caption{Resultat einer SPARQL Abfrage mittels \textit{BOUND}-Filter\protect\footnotemark}
\end{table}
\footnotetext{\cite[17.4.1.1 BOUND]{w3sparql_querylang}}

Es wird also nur die Person \textit{``Bob''} gefunden, da nur diese Person gemäss definierter Ontologie über eine Relation zu einem Datum verfügt.

\subsubsection{IF}
\label{subsec:sparql_ausdruecke_funktionen_if}
Die \textit{IF}-Funktion benötigt drei Argumente als Parameter. Dabei fasst sie das erste Argument als Wahrheitswert zur Auswertung auf. Das zweite Argument wird zurückgegeben, wenn der Ausdruck des erten Argumentes wahr ist. Das dritte Argument wird zurückgegeben, wenn der Ausdruck des ersten Argumentes falsch ist.

\lstset{caption={Beispiel der \textit{IF}-Funktion in SPARQL},captionpos=b,language=XML}
\begin{lstlisting}
IF(?a = 2,?b,?c)
\end{lstlisting}

Oder, informal, in prozeduraler Programmierung ausgedrückt:
\lstset{caption={Beispiel einer simplen Ontologie zur Nutzung der \textit{BOUND}-Funktion in einer Abfrage\protect\footnotemark},captionpos=b}
\lstset{caption={Beispiel der \textit{IF}-Funktion in SPARQL anhand prozeduraler Programmierung},
    captionpos=b,
    language=Java
}
\begin{lstlisting}
if (a == 2) {
    return b;
} else {
    return c;
}
\end{lstlisting}

\subsubsection{IN}
\label{subsec:sparql_ausdruecke_funktionen_in}
Die \textit{IN}-Funktion teste, ob der Paramter, welcher direkt vor ihrem Aufruf folgt, in dem Listenausdruck vorkommt, welche direkt nach ihrem Aufruf folgt. Ist dies der Fall, so gibt die Funktion den Wahrheitswert wahr zurück, ansonsten falsch.

\lstset{caption={Beispiel der \textit{IN}-Funktion in SPARQL},captionpos=b,language=SQL}
\begin{lstlisting}
2 IN (1, 2, 3) % Wahr
2 IN ()        % Falsch
\end{lstlisting}
\footnotetext{\cite[17.4.1.9 IN]{w3sparql_querylang}}
In den obigen Beispielen wäre der erste Ausdruck also wahr, da 2 in der gegebenen Liste von (1, 2, 3) vorkommt, der zweite Ausdruck falsch, da 2 nicht in der leeren Menge vorkommt.

Analog zur \textit{IN}-Funktion exisiert die \textit{NOT IN}-Funktion. Es handelt sich dabei um die Negation der \textit{IN}-Funktion.
