\chapter{RDF und OWL}
\label{chap:owl_Rdf}
Jetzt haben wir einen Überblick über die verschiedenen Methoden und Herangehensweisen zur Generierung von Knowledge Engineering. Auch die wichtigsten theoretischen Grundlagen haben wir mit den vorigen Kapiteln abgedeckt. Im Kapitel \nameref{chap:ontologien} haben wir gelernt, dass für die Darstellung von Ontologien verschiedene Sprachen entwickelt wurden. In Diesem Beispiel wird eine der bekanntesten Ontologie Sprachen OWL (Web Ontology Language) verwendet. OWL basiert auf der RDF Syntax. Folglich scheint es uns wichtig diese zwei Sprachen kurz vorzustellen.

\section{RDF}
\label{sec:owlRdf_rdf}

Das RDF Kapitel basiert auf der Spezifikation von w3 \cite{w3rdf}.\\
Das "`Resource Description Framework"' RDF ist ein Framework um Informationen aus Ressourcen zu formulieren. Ressourcen können Dokumente, Leute, Objekte aber auch abstrakter Inhalt darstellen. Mit RDF können Informationen im Web von Anwendungen verarbeitet werden, anstatt sie nur anzuzeigen. RDF bietet ein gemeinsames Framework um die Informationen zwischen Anwendungen auszutauschen ohne Bedeutung zu verlieren. 

RDF ist die Grundlage für Sematic Web, welches seine Flexibilität ausnützt. Alle Daten im Semantic Web werden in RDF abgebildet. Wichtig dabei ist, dass RDF es ermöglicht Daten zu verknüpfen. Dies führt dazu, dass zu einer Ressource mehr Informationen zusammen getragen werden.\cite{cambSemRDF}

%\subsection{Einsatzgebiete}
%\label{sec:logischeProgrammierung_herkunft_einsatz}
\subsection{RDF Data Model}
\label{subsec:owlRdf_rdf_dataModel}
Die Informationen werden in RDF als Aussagen abgebildet. Der Aufbau dieser  ist immer gleich und weist die folgende Struktur eines Tripels auf:

\noindent\hspace*{15mm}<Subjekt><Prädikat><Objekt>

Eine RDF Aussage bildet eine Beziehung zwischen zwei Ressourcen (Entitäten) ab. 
Subjekt und Objekt stellen die zwei Ressourcen dar. Das Prädikat repräsentiert die Beziehung zwischen den zwei Ressourcen Subjekt und Objekt. Die Beziehung wird in RDF als Property abgebildet. 
 
\noindent\hspace*{15mm} <Eine Programmiersprache> <hat> <ein Programmierparadigma>


Eine Entität kann in mehreren Tripeln referenziert werden. Es ist zudem möglich eine Ressource in einer Aussage als Objekt und in einer Anderen als Subjekt zu verwenden. dies ermöglicht es, Verbindungen zwischen mehreren Tripeln herzustellen. Dies ist ein wichtiger Teil von RDF.

Tripel werden in sogenannte RDF Graphen abgebildet. Diese bestehen aus Knoten und Pfeilen. die Subjekte und die Objekte werden als Knoten, die Prädikate als Pfeile dargestellt. Genaueres dazu findet sich im Kapitel \nameref{chap:graph_data}



TODO Bildli von Unserer Ontologie

Es gibt drei Typen von RDF Daten, welche in Tripeln auftreten, IRIs (oder Ressource Knoten) Literale und Blank (Leere) Knoten.

\subsubsection{IRIs (International Resource Identifier)}
\label{sec:owlRdf_rdf_dataModel_iris}
Wie der Name schon sagt, stellt ein IRI  eine Ressource dar. Dabei handelt es sich um einen globalen Identifier, IRIS können also von verschiedenen Nutzern wiederverwendet werden. Es gibt verschieden Formen von IRIs, so zum Beispiel die URLs welche als Web Adresse verwendet werden. Eine Andere Form der IRI bietet eine Kennung für eine Ressource ohne den Standort oder den Zugriff preiszugeben.% IRIs sind im RFC 3987 spezifiziert.

\noindent\hspace*{15mm}IRIs kann in allen drei Positionen eines Tripels auftreten.

\subsubsection{Literale Knoten}
\label{sec:owlRdf_rdf_dataModel_literal}
Der Begriff Literal wird als Synonym für Wert verwendet. Es handelt sich bei Literalen also um Basicwerte die nicht IRIS sind. Literale können Strings, Datumswerte oder auch Nummern sein. Um die Werte richtig zu interpretieren, haben Literale einen Datentyp zugeordnet. Ein String kann zusätzlich eine Sprache zugewiesen haben.

Literale können in einem Tripel nur als Objekt verwendet werden.

\subsubsection{Blank Nodes}
\label{sec:owlRdf_rdf_dataModel_blankNodes}
Ein leerer Knoten stellt eine Ressource ohne URI dar. Der Vorteil dieser Knoten ist, dass es keinen globalen Identifier braucht. Leere Knoten können mit einer einfachen Variable in der Algebra verglichen werden. Sie bilden ein Objekt ab, wobei der Wert zweitrangig ist. 

\noindent\hspace*{15mm} Leere Knoten können in einem Tripel in der Subjekt oder der Objekt Position stehen.


\subsubsection{Multiple Graphs}
\label{sec:owlRdf_rdf_dataModel_multipleGraphs}

TODO: brauchts das?

\subsection{RDF Vokabular}
\label{sec:owlRdf_rdf_voca}
RDF wird typischerweise in Kombination mit Vokabular und Konventionen verwendet, welche Semantische Daten zu Ressourcen zur Verfügung stellen.

Um das Vokabular von RDF zu zu definieren wird die RDF Schema Sprache unterstützt. Diese ermöglicht semantische Eigenschaften der RDF Daten zu definieren. Es kann damit festgelegt werden, welche Ressourcen an welcher Position verwendet werden.

so verwendet RDF zum Beispiel die Bezeichnung der Klasse um zu kategorisieren. Die Beziehungen zwischen Instanzen werden in Propertys abgebildet. Mit RDF können auch Hierarchien im Bereich der Klassen aber auch der Eigenschaften gebildet werden. Ausserdem können auf Objekten und Subjekten Typeinschränkungen vorgenommen werden. In der Tabelle\ref{tab:SchematischeKonstrukte} findet sich eine kurze Übersicht der wichtigsten Konstrukte.

TODO: Soll das anderst dargestellt werden? wieso geht mein footnote nicht??
\begin{center}
	\begin{table}[H]
	 \centering
		%\caption{Schematische Konstrukte}	\footnote{\cite{w3rdf}}
				\caption[\cite{w3rdf}]{Schematische Konstrukte \footnotemark}
			\begin{tabular}{|l|l|l|} \toprule
			\textbf{Konstrukt}  & \textbf{Syntaktische Form} & \textbf{Beschreibung} \\ \midrule
				Class (eine Klasse) & C rdf:type; rdfs:Class& C (eine Ressource) \\&&ist eine RDF Klasse \\  \midrule		
				Property (Eine Klasse) & P rdf:type rdf:Property & P (eine Ressource)\\&& ist eine RDF Property\\  \midrule		
				type (eine Eigenschaft) & I rdf:type C &I (eine Ressource)\\&& ist eine Instanz von C (einer Klasse)\\  \midrule
subClassOf (eine Eigenschaft) & C1 rdfs:subClassOf C2 & C1 (eine Klasse)\\&& ist Subklasse von C2 \\  \midrule
subProptertyOf (eine Eigenschaft) & P1 rdfs:subProptertyOf P2 & P1 (eine Eigenschaft)\\&& ist Sub-Property von P2 \\  \midrule
domain (eine Eigenschaft) & P rdfs:domain C & Domäne von P \\&&(einer Eigenschaft) ist C (eine Klasse) \\  \midrule			
range (eine Eigenschaft) & P rdfs:range C & Bereich von P \\&&(einer Eigenschaft) ist C (eine Klasse) \\  \bottomrule
			\end{tabular}
		\label{tab:SchematischeKonstrukte}
	\end{table}
\end{center}


TODO: Writing RDF graphs wird hier noch ausführlich beschrieben. Nach dem Kapital Graphen Modellierung entscheiden was davon noch nötig ist und einfügen.

\section{OWL}
\label{sec:owlRdf_owl}

Das folgende Kapitel Basiert auf der w3.org Spezifikation.\cite{w3owl} Bei OWL (Web Ontology Language) und OWL2 handelt es sich um die Ontologie Sprache für das Semantische Web.\cite{cambSemOWL} Also um eine Sprache um Ontologien auszudrücken. Wie bei RDF wurde OWL Entwickelt um Informationen nicht nur anzuzeigen sondern auch zu verarbeiten. Durch zusätzliches Vokabular wie zum Beispiel Beziehungen zwischen Klassen und erweiterte formale Semantik hat der Benutzer mehr Möglichkeiten als bei RDF oder auch XML. \\OWL basiert aber technische gesehen auf der RDF Syntax. %Die Verknüpfung und Darstellung von Termen in Vokabularien und deren Verknüpfungen wird in OWL als Ontologie bezeichnet. Besonders an OWL ist ausserdem, dass es maschineninterpretierbare Inhalt im Web repräsentieren.  

\subsection{OWL Syntax}
\label{subsec:owlRdf_owl_syntax}
Für OWl stehen verschiedene Schreibweisen zur Verfügung, welche für verschieden Anwendungszwecke gedacht sind:
\begin{itemize}
	\item RDF/XML Syntax für OWL: entspricht RDF/XML Syntax mit einer speziellen Übersetzen für OWL Konstrukte. Dabei handelt es sich um die einzige Syntax, welche von allen OWL 2 Tools unterstützt werden soll.
	\item OWL/XML Syntax: XML Syntax für OWL
	\item Functional-Style Syntax: Zur Vereinfachung von Spezifikationszweck; Unterstützt Grundlagen zur Implementation von OWL 2 wie APIs und Reasoners
	\item Turtle Syntax: TODO 
	\item Manchester Syntax: Vereinfacht das lesen für nicht logik affine Leser.
\end{itemize}
es gibt Werkzeuge, welche die Übersetzung zwischen den verschiedenen Schreibweisen vornimmt.

Bei OWL2 handelt es sich nicht um eine Schemasprache. Im Gegensatz zu XML beschreibt OWL nicht wie ein Dokument aufgebaut sein muss. So kann auch nicht vorgeschrieben werden, das ein bestimmtes Element vorhanden sein muss.


\subsection{Wissen modellieren}
\label{subsec:owlRdf_owl_wissenModellieren}
bei OWL handelt sich also um eine Wissensbasierte Repräsentationssprache. Sie bildet Wissen einer Domäne ab. Es wird also versucht, eine Domäne in OWL so abzubilden, dass das menschliche Wissen wiederspiegelt wird. Dabei gibt es keine Möglichkeit, sämtliche Aspekte des menschlichen Wissens abzubilden. OWL kann aber als mächtige Modellierungssprache bezeichnet wird. Das Ergebnis einer Modellierung nennt man Ontologie.

Um das Abbilden von Wissen zu erklären, wird in den folgenden Abschnitten der Grundsätzliche Aufbau von OWL beschrieben. Die Grundlegenden Elemente werden als Axiome, Entitäten und Expressions (Ausdrücke) bezeichnet.


\begin{itemize}
	\item Axiom: Basis Statements;\\ Grundaussagen  oder Basispropositionen wie "`Prolog verwendet Unifikation"' werden in OWL Axiome genannt. Es handelt sich  um "`Stücke des Wissens "` welche je nach Sachlage wahr oder falsch sein können. Dies unterscheidet Axiome grundlegend von Entitäten und Expression.
	\item Entitäten; Elemente welche konkrete Objekte aus der realen Welt abbilden:\\Grundbestandteile einer Aussage wie zum Beispiel die Objekte Prolog und Unifikation oder die Beziehung verwendet, werden allgemein Entitäten genannt. Konkrete Objekte werden dabei als Individuals, Kategorien als Klassen und  Beziehungen als Properties bezeichnet. Beziehungen werden Unterteilt in ObjectProperties (Wert zu Objekt), DataTypProperties (Datenwert zu Ojbekt) und AnnotationProperties (Information zu der Ontologie selber).
	\item Expression (Ausdruck); kombinationen aus Enitiäten um komplexe Beschreibungen aufzubauen:\\ Entitäten können mithilfe eines Konstruktors kombiniert werden. Zum Beispiele Prolog und die Klasse Unifikation. Diese Vereinigung wird als Class Expression abgebildet und könnte als neue Entität angesehen werden. (todo Beispiel). Die Expressionsprache für Klassen ist sehr mächtig; Expressionsprache für Properties hingegen ist schwächer. 
\end{itemize}
Ein Mensch kann Schlussfolgern. Er kann nachvollziehen, das es Situationen gibt, bei welcher aus einer Tatsache eine nächste Folgt. Wenn also eine Aussage wahr ist, folgt daraus, dass eine andere auch zutrifft. Dies wird in OWL Tools, sogenannten Reasoners, umgesetzt. Ein Reasoner kann also Konsequenzen ermitteln. Es kann schwierig zu verstehen sein, wie Axiome miteinander interagieren. Dieser Zusammenhang kann als Stärke und als Schwäche von OWL angeschaut werden. Eine Stärke, weil er Reasoner informationen aufdeckt, welche ein Mensch nicht erkennen würde. Eine Schwäche weil es schwer ist, die unmittelbare Wirkung vorherzusehen.

\subsection{Die wichtigsten Elemente von OWL}
\label{subsec:owlRdf_owl_wichtigsteElemente}

\subsubsection{Classes, Subclasses und Individuals }
\label{subsubsec:owlRdf_owl_wissenModellieren_wichtigsteElemente_Classen}


Klassen: EinfachesToken ist eine Klasse \\
\begin{lstlisting}
<owl:Class rdf:about="http://www.semanticweb.org/mira/ontologies/2014/9/FamilyOnto\#Father"/> \\ 
\end{lstlisting}

Subklassen: EinfachesToken ist Subklass von SprachElement \\
\begin{lstlisting}
<owl:Class rdf:about="http://www.semanticweb.org/mira/ontologies/2014/9/FamilyOnto\#Father">
	<rdfs:subClassOf rdf:resource="http://www.semanticweb.org/mira/ontologies/2014/9/FamilyOnto#Parent"/>
</owl:Class>
\end{lstlisting}		
Subklassen werden nicht nur verwendet um Abhängigkeiten darzustellen sondern auch um Klassen Hierarchien zu modellieren. Also ein Abbilden der allgemeinen Beziehung der Klassen. Zum Beispiel die Relation:  Prolog ist eine Programmiersprache.\\

		
Individuum:Es gibt ein NamedIndividual der Klasse einfaches Token mit der Bezeichnung Atom. Individuals können auch von mehreren Klassen gleichzeitig sein\\
\begin{lstlisting}
<NamedIndividual rdf:about="'\&Prolog\_Ontology;Atom"'>\\
	<rdf:type rdf:resource="\&Prolog\_Ontology;EinfachesToken"/>\\
	<rdfs:comment>beginnt mit Kleinbuchstaben oder mit Apostroph</rdfs:comment>\\
</NamedIndividual>\\
\end{lstlisting}
                                                      		

Klassen könne gleichgestellt werden: Die Klasse Person und die Klasse Human entsprechen sich. TODO Bsp aus unserer Hirachie sobald wirs haben.\\
\noindent\hspace*{15mm} <owl:Class rdf:about="Person"'>\\
\noindent\hspace*{25mm}  <owl:equivalentClass rdf:resource="Human"/>\\
\noindent\hspace*{15mm}</owl:Class>\\


Klassen gegenseitig Ausschliessen: Idividuals dürfen nur von der Klasse Woman oder der Klasse Man sein (TODO Beispiel sobald wir eins haben)\\
\noindent\hspace*{15mm}<owl:AllDisjointClasses>\\
\noindent\hspace*{25mm}   <owl:members rdf:parseType="Collection"'>\\
\noindent\hspace*{35mm}     <owl:Class rdf:about="Woman"/>\\
\noindent\hspace*{35mm}     <owl:Class rdf:about="Man"/>\\
\noindent\hspace*{25mm}   </owl:members>\\
\noindent\hspace*{15mm} </owl:AllDisjointClasses> \\


\label{subsubsec:owlRdf_owl_wissenModellieren_wichtigsteElemente_Propertys}


Objekt Eigenschaft: Es gibt eine Beziehung verwendet zwischen zwei Klassen\\
\noindent\hspace*{15mm} ObjectProperty -  <ObjectProperty rdf:about="\&Prolog\_Ontology;verwendet"/>\\

\noindent\hspace*{15mm}<rdf:Description rdf:about="John"'>\\
\noindent\hspace*{25mm}   <hasWife rdf:resource="Mary"/> \\
\noindent\hspace*{15mm} </rdf:Description>\\
TODO: ds gibts bei uns niergens, ich glaub wir haben da noch was falsch!\\

%Restriciton:             <Restriction>
%                <onProperty rdf:resource="\&Prolog\_Ontology;hatSyntaxElement"/>
%                <someValuesFrom rdf:resource="\&Prolog\_Ontology;Token"/>
%</Restriction> - Prolog verwendet Token
						
Subeigenschaft: Eigenschaft hasWife ist Subeigenschaft von Eigenschaft hasSpouse	(TODO: beispiel aus unserer Ontology sobald wir diese Form nutzten)\\										
\noindent\hspace*{15mm}subPropertyOf:  <owl:ObjectProperty rdf:about="hasWife"'>\\
\noindent\hspace*{25mm}  <rdfs:subPropertyOf rdf:resource="hasSpouse"'/>\\
\noindent\hspace*{15mm}</owl:ObjectProperty  - Property A ist supProperty von B\\


Es kann eingeschränkt werden auf welche und mit welcher Klasse einer Domäne eine Objekteigenschaft angewendet werden darf: die Beziehung hatSyntaxElement darf auf Prolog mit Token angewendet werden.\\
\noindent\hspace*{15mm}    <ObjectProperty rdf:about="\&Prolog\_Ontology;hatSyntaxElement"'>\\
\noindent\hspace*{25mm}       <rdfs:domain rdf:resource="\&Prolog\_Ontology;Prolog"/>\\
\noindent\hspace*{25mm}       <rdfs:range rdf:resource="\&Prolog\_Ontology;Token"/>\\
\noindent\hspace*{15mm}    </ObjectProperty>\\
		
		
Verschiedenheit von Individuen festlegen:  Atom und Variablen sind unterschiedliche Individuen.\\
\noindent\hspace*{15mm}<rdf:Description rdf:about="Konstante"'>\\
\noindent\hspace*{25mm}  <owl:differentFrom rdf:resource="Variable"/>\\
\noindent\hspace*{15mm} </rdf:Description>\\


 Verschiedenheit kann so festgelegt werden:\\
\noindent\hspace*{15mm}   <rdf:Description>\\
\noindent\hspace*{25mm}       <rdf:type rdf:resource="\&owl;AllDifferent"'/>\\
\noindent\hspace*{35mm}       <distinctMembers rdf:parseType="Collection"'>\\
\noindent\hspace*{45mm}           <rdf:Description rdf:about="\&Prolog\_Ontology;Konstante"'/>\\
\noindent\hspace*{45mm}           <rdf:Description rdf:about="\&Prolog\_Ontology;Variable"'/>\\
\noindent\hspace*{35mm}           <rdf:Description rdf:about="\&Prolog\_Ontology;Zahl"/>\\
\noindent\hspace*{25mm}        </distinctMembers>\\
\noindent\hspace*{15mm}   </rdf:Description>\\


Individuen miteinander gleich setzten: Atom und Konstante sind das gleiche Individuum.\\
\noindent\hspace*{15mm}    <NamedIndividual rdf:about="'\&Prolog\_Ontology;Atom"'>\\
\noindent\hspace*{25mm}        <rdf:type rdf:resource="'\&Prolog\_Ontology;EinfachesToken"'/>\\
\noindent\hspace*{25mm}        <rdfs:comment>beginnt mit Kleinbuchstaben oder mit Apostroph</rdfs:comment>\\
\noindent\hspace*{25mm}        <sameAs rdf:resource="'\&Prolog\_Ontology;Konstante"'/>\\
\noindent\hspace*{15mm}    </NamedIndividual>\\



Datentypen Eigenschaft: TODO: bei uns anwenden.\\
\noindent\hspace*{15mm} <Person rdf:about="'John"'>\\
\noindent\hspace*{25mm}   <hasAge rdf:datatype="http://www.w3.org/2001/XMLSchema\#integer"'>51</hasAge>\\
\noindent\hspace*{15mm} </Person>\\

\subsection{Ontologien}
\label{subsec:owlRdf_owl_Ontologien}

Die gesamten Informationen zu einem Thema werden in Ontologien gesamelt. Diese können von verschiedenen Anwendungen genutzt werden.

\noindent\hspace*{15mm}<rdf:RDF ...>
\noindent\hspace*{25mm}  <owl:Ontology rdf:about="http://example.com/owl/families"/>
\noindent\hspace*{25mm}  ...
\noindent\hspace*{15mm} </rdf:RDF>

Ontologien werden in OWL Dokumenten abgespeichert. Diese werden auf localen Dateisystemen oder im World Wide Web hinterlegt.\\
Beim Schreiben einer Ontologie können zusätzliche Namespaces verwendet werden. Wie zum Beispiel http://www.w3.org/2001/XMLSchema\#. Dabei ist zu berücksichtigen, dass diese Namespaces kontrolierbar sein sollten. ? So e schwachsin das isch jo logisch.\\

Ausserdem können Informationen aus einer Ontologie in einer anderen verwendet werden. Dies muss dazu importiert werden.\\
 \noindent\hspace*{15mm}<owl:Ontology rdf:about="http://example.com/owl/families\">\\
 \noindent\hspace*{25mm}  <owl:imports rdf:resource="http://example.org/otherOntologies/families.owl" />\\
 \noindent\hspace*{15mm}</owl:Ontology>\\

Um bei der verwendung von Objekten aus anderen Ontologien eine Umbenennung zu umgehen, kann auf das entsprechende Objekt referenziert werden.\\

 \noindent\hspace*{15mm}<owl:DatatypeProperty rdf:about="hasAge">\\
 \noindent\hspace*{25mm}  <owl:equivalentProperty rdf:resource="\&otherOnt;age"/>\\
 \noindent\hspace*{15mm}</owl:DatatypeProperty>\\

\subsection{OWL Tools}
\label{subsec:owlRdf_owl_OwlTools}


Es wird typischerweise zwischen zwei Arten von Ontologiewerkzeugen unterschieden. Der Editor (Bearbeiter) welcher fürs erzeugen und ändern von Ontologien zuständig ist. Und der Reasoner welcher fähig ist logische folgerungen aus dem bestehenden Wissen abzuleiten.


\subsection{OWL Untersprachen}
\label{subsec:owlRdf_owl_Untersprachen}
OWL ist in drei Untersprachen gegliedert. Jede dieser Sprachen wurde für Verwendung durch verschiedene Gruppen entwickelt. Dabei handelt es sich um OWL Lite, OWL DL und OWL Full. Die neue Version OWL2 unterscheidet zusätzlich in OWL2 QL, OWL2 EL und OWL2 RL. Dabei handelt es sich um weitere Unterklassen von OWL2 DL welche wiederum eine Untersprache von OWL2 Full ist.



%w3c
%http://www.w3.org/TR/2012/REC-owl2-primer-20121211/
%http://www.w3.org/2001/sw/wiki/OWL

%http://www.w3.org/TR/2014/NOTE-rdf11-primer-20140624/

% Einträge im Verzeichnis erscheinen lassen ohne hier eine Referenz einzufügen
%\nocite{kopka:band1}
